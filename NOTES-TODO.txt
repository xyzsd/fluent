

MASTER TO DO LIST
=================

(1) parser fixes/improvements
    Option.of() check, needed?

(6) function tests
    this is a very large test surface, so we may only test essentials
    expected functions (NUMBER, DATETIME), and LIST should be tested thoroughly

    ** make sure FluentFunctionException.of() is being properly used!!

(7) make sure fluentBundle has a formatPattern(Pattern) public
    useful for term formatting/usage/etc.

(9) FluentBundle / API streamlining. Error handling has been markedly improved.
    FluentBundle :: use BundleException for errors
    fix 'experimental' parts (FmtBuilder)

(10) look at all code 'TODOs'

(12) spotbugs

(13) DOCUMENTATION (particularly functions, etc.) and FluentBundle/etc.
        * also why Fluent vs. ICU::MF2

(14) EXAMPLES in documentation
        * how to read in FTL
        * how to replace DATETIME with TEMPORAL

(15) performance testing, w/and w/o cache. cache improvements.
     Message rendering performance (more important than parser improvements, really)
     Also evaluate cache design, locks, etc. Goal is a simple but useful cache, and
     ability to change to a 'real' cache as needed.



(16) Locale fallback
     perhaps just use ICU:LocaleMatcher
        ICU:LocaleMatcher.Builder
     this would be provided by (user-supplied)
        * direclty specified in code
        * look at some sort of configuration file with supported locales
        * or, by scanning file system/classpath
     LocaleMatcher.getBestLocale()
     then get bundle.

     NOTE: this is all handled by ICU; we should give an example BUT not much to code here.

     using localemather, get tags, and file would be

     myFtlFile_en-GB.ftl
     {basename}_{languagetag}.{extension}



    need a simple/easy approach; currently we have no fallback process
    - language matching
      - how to search/match classpath for resource fork/language matching
          - or a group of files/urls/etc.
          - a couple of ways:
            - provide known languages ahead of time
              - string paths, 'paths', URIs, depends. associate with locale
              - then use localematcher
            - OR
            - probe (e.g., en_gb -> en -> root) (root or fallback)
            - via constructing an array of names:
                  'en_gb_xx' -> en_gb_xx, en_gb, en, FALLBACK (if defined) or ""
                  but really what if there was en_gb, en_us, and fr
                 how would en_xx fall back to en_gb/en_us ? unless we knew about it
                 how would en_xx fall back to en_gb/en_us ? unless we knew about it


