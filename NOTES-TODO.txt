

MASTER TO DO LIST
=================

(1) parser fixes/improvements

(2) parser performance

(3) crMultiKeyTest, crMultilineValueTest
    <CR> :
        omitting CR at EOF.
    handle <CR> appropriately
    seems to be mainly at/near EOF
    but evaluate potential spacing difference on multikey test
    junk test fixed after changing to octet-based stream parser, which could potentially fix additional bugs

(4) ? AST optimizations ?
    - nested placeables -> collapse (if constant)
    - merge adjacent TextElements/constant placeables into a single TextElement
    - need to look at actual ASTs in more detail, to see if this is useful

(5) ? feature (low priority)
    easier ways to extract comments from a resource bundle (if we parse them)

(6) function tests
    this is a very large test surface, so we may only test essentials

(7) make sure fluentBundle has a formatPattern(Pattern)
    useful for term formatting/usage/etc.

(8) simple diagnostics
    FluentBundle::toString(): should print bundle name, # of terms, messages, locale (simple diagnostic info)
(9) FluentBundle / API streamlining. Error handling has been markedly improved.

(10) look at all code 'TODOs'

(11) smoketest bugs
    literal doubles / formatting
    EN_US_POSIX uses 6 digits, otherwise 3 (!)
    need to investigate ICU number format

(12) spotbugs / errorprone

(13) DOCUMENTATION (particularly functions, etc.) and FluentBundle/etc.
        * also why Fluent vs. ICU::MF2

(14) EXAMPLES in documentation
        * how to read in FTL
        * how to replace DATETIME with TEMPORAL

(15) performance testing, w/and w/o cache. cache improvements.
     Message rendering performance (more important than parser improvements, really)

(16) Locale fallback
    need a simple/easy approach; currently we have no fallback process
    - language matching
      - how to search/match classpath for resource fork/language matching
          - or a group of files/urls/etc.
          - a couple of ways:
            - provide known languages ahead of time
              - string paths, 'paths', URIs, depends. associate with locale
              - then use localematcher
            - OR
            - probe (e.g., en_gb -> en -> root) (root or fallback)
            - via constructing an array of names:
                  'en_gb_xx' -> en_gb_xx, en_gb, en, FALLBACK (if defined) or ""
                  but really what if there was en_gb, en_us, and fr
                 how would en_xx fall back to en_gb/en_us ? unless we knew about it
                 how would en_xx fall back to en_gb/en_us ? unless we knew about it


